const pyCode = String.raw`
from typing import List, Tuple, Dict, Optional

def parse_feature_table(lines: List[str]):
    sections = []
    current_header: Optional[str] = None
    current_features: List[Dict] = []
    current_feature: Optional[Dict] = None

    def finalize_feature():
        nonlocal current_feature, current_features
        if current_feature is not None:
            current_features.append(current_feature)
            current_feature = None

    def finalize_section():
        nonlocal current_header, current_features, sections
        if current_header is not None:
            sections.append((current_header, current_features))
        current_header = None
        current_features = []

    for raw in lines:
        line = raw.rstrip('\\n')
        if not line:
            finalize_feature()
            continue
        if line.startswith('>Feature'):
            finalize_feature()
            finalize_section()
            current_header = line
            current_features = []
            continue
        parts = line.split('\\t')
        if len(parts) < 5:
            parts += [''] * (5 - len(parts))
        c1, c2, c3, c4, c5 = (p.strip() for p in parts[:5])
        if c3:  # start of a new feature
            finalize_feature()
            if not c1 or not c2:
                raise ValueError(f"Malformed feature line (missing start/end): {line}")
            current_feature = { 'intervals': [(c1, c2)], 'key': c3, 'qualifiers': [] }
            continue
        if c1 and c2 and not c4 and not c5:
            if current_feature is None:
                raise ValueError(f"Interval without an active feature: {line}")
            current_feature['intervals'].append((c1, c2))
            continue
        if c4:
            if current_feature is None:
                raise ValueError(f"Qualifier without an active feature: {line}")
            current_feature['qualifiers'].append((c4, c5))
            continue

    finalize_feature()
    finalize_section()
    return sections

def filter_sections_by_qual_value(sections, search_value: str):
    sval = search_value.lower()
    filtered = []
    for header, features in sections:
        kept = []
        for feat in features:
            match = any((val is not None and sval in str(val).lower()) for (_k, val) in feat["qualifiers"])
            if match:
                kept.append(feat)
        filtered.append((header, kept))
    return filtered

def render_feature_table(sections_filtered) -> List[str]:
    out_lines: List[str] = []
    for header, feats in sections_filtered:
        if not feats:
            continue
        out_lines.append(header)
        for feat in feats:
            intervals = feat["intervals"]
            key = feat["key"]
            qualifiers = feat["qualifiers"]
            s0, e0 = intervals[0]
            out_lines.append('\\t'.join([s0, e0, key, '', '']))
            for (s, e) in intervals[1:]:
                out_lines.append('\\t'.join([s, e, '', '', '']))
            for (qk, qv) in qualifiers:
                out_lines.append('\\t'.join(['', '', '', qk, qv]))
    return out_lines

def filter_table(file_text: str, query: str):
    lines = file_text.split('\\n')
    sections = parse_feature_table(lines)
    filtered = filter_sections_by_qual_value(sections, query)
    rendered = render_feature_table(filtered)
    total_matches = sum(len(feats) for _, feats in filtered)
    return '\\n'.join(rendered) + ('\\n' if rendered else ''), total_matches
`;
