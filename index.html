<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>BOTO Genomics Tools</title>
  <link rel="stylesheet" href="assets/app.css" />
  <style>
    /* Minimal extras just for the mesh canvas layout */
    body { overflow-x: hidden; }
    #mesh-bg {
      position: fixed; inset: 0; z-index: 0; pointer-events: none; display:block;
    }
    .site-wrap { position: relative; z-index: 1; }
    /* Simple landing layout */
    .hero { max-width:1100px; margin: clamp(24px,6vw,64px) auto; padding: 24px; }
    .tool-list a { color: var(--fg); }
  </style>
</head>
<body>
  <!-- Cursor-driven mesh background -->
  <canvas id="mesh-bg" aria-hidden="true"></canvas>

  <!-- Normal page content -->
  <div class="site-wrap">
    <div class="container">
      <div class="card hero">
        <h1>Genomics Tools</h1>
        <p>Pick a tool:</p>
        <ul class="tool-list">
          <li><a href="tools/feature-filter.html">NCBI 5‑Column Feature Table Filter</a></li>
        </ul>
      </div>
      <div class="footer">All tools run locally in your browser via Pyodide.</div>
    </div>
  </div>

  <script>
  (function(){
    const canvas = document.getElementById('mesh-bg');
    const ctx = canvas.getContext('2d', { alpha: true });

    // ===== Tunables you can tweak later =====
    const TILE = 28;          // px size of each square tile (bigger = fewer tiles, faster)
    const RADIUS = 240;       // px influence radius from cursor
    const POWER = 1.8;        // falloff curve; 1 = linear, >1 = steeper falloff
    const MAX_Z = 12;         // max "protrusion" in px (visual strength)
    const BG = '#1c7c99';     // base tile color (matches --surface)
    const HILITE = 24;        // how much to lighten near the cursor (0–40 looks nice)
    const SHADOW = 0.35;      // shadow strength near the cursor (0–0.6)

    // Reduced motion? draw a static, subtle mesh and exit
    const prefersReduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

    let dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    let width = 0, height = 0, cols = 0, rows = 0;

    // Precompute tile centers for speed
    let centers = [];

    function resize(){
      const w = Math.ceil(window.innerWidth);
      const h = Math.ceil(window.innerHeight);
      if (w === width && h === height) return;
      width = w; height = h;
      canvas.width = Math.floor(width * dpr);
      canvas.height = Math.floor(height * dpr);
      canvas.style.width = width + 'px';
      canvas.style.height = height + 'px';
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

      cols = Math.ceil(width / TILE);
      rows = Math.ceil(height / TILE);
      centers = new Array(rows * cols);
      let i = 0;
      for (let r = 0; r < rows; r++){
        for (let c = 0; c < cols; c++){
          centers[i++] = [c * TILE + TILE/2, r * TILE + TILE/2];
        }
      }
      if (prefersReduced) drawStatic();
    }

    // Utilities
    function lerp(a,b,t){ return a + (b-a)*t; }
    function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }
    function lighten(hex, amt){
      // quick HSL-ish lighten in sRGB
      const c = hex.replace('#','');
      const num = parseInt(c.length===3 ? c.split('').map(ch=>ch+ch).join('') : c, 16);
      let r = (num >> 16) & 255, g = (num >> 8) & 255, b = num & 255;
      r = clamp(Math.round(lerp(r,255, amt/100)), 0, 255);
      g = clamp(Math.round(lerp(g,255, amt/100)), 0, 255);
      b = clamp(Math.round(lerp(b,255, amt/100)), 0, 255);
      return `rgb(${r},${g},${b})`;
    }

    function drawStatic(){
      ctx.clearRect(0,0,width,height);
      // soft grid without protrusion
      for (let r = 0; r < rows; r++){
        for (let c = 0; c < cols; c++){
          const x = c * TILE, y = r * TILE;
          ctx.fillStyle = BG;
          ctx.fillRect(x, y, TILE-1, TILE-1); // -1 gap for subtle grid lines
        }
      }
    }

    let targetX = width/2, targetY = height/2;
    let curX = targetX, curY = targetY;
    const SMOOTH = 0.28;  // lower = floaty, higher = snappier

    window.addEventListener('mousemove', (e)=>{
      targetX = e.clientX; targetY = e.clientY;
      if (prefersReduced) return; // ignore
      // also draw immediately once to avoid lag when first moving
      if (!animating) { animating = true; requestAnimationFrame(tick); }
    }, { passive: true });

    window.addEventListener('resize', resize);
    resize();

    if (prefersReduced) return; // stop here for reduced-motion users

    let animating = true;
    function tick(){
      curX += (targetX - curX) * SMOOTH;
      curY += (targetY - curY) * SMOOTH;

      ctx.clearRect(0,0,width,height);

      // Draw tiles with depth illusion based on distance to cursor
      let i = 0;
      for (let r = 0; r < rows; r++){
        for (let c = 0; c < cols; c++){
          const cx = centers[i][0];
          const cy = centers[i][1];
          i++;
          const dx = cx - curX, dy = cy - curY;
          const dist = Math.hypot(dx, dy);
          let t = 1 - (dist / RADIUS);
          if (t < 0) t = 0; else t = Math.pow(t, POWER);

          const x = c * TILE, y = r * TILE;
          const lift = t * MAX_Z; // vertical lift in px

          // Shade and shadow
          const fill = lighten(BG, t * HILITE);
          ctx.fillStyle = fill;
          if (t > 0){
            ctx.shadowColor = `rgba(0,0,0,${t * SHADOW})`;
            ctx.shadowBlur = 10 * t;
            ctx.shadowOffsetY = 6 * t;
          } else {
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0; ctx.shadowOffsetY = 0;
          }

          // Draw lifted square (as if extruding towards viewer)
          // We simulate lift by shifting up-left slightly
          ctx.fillRect(x - lift*0.25, y - lift*0.35, TILE-1 + lift*0.5, TILE-1 + lift*0.7);
        }
      }

      requestAnimationFrame(tick);
    }
    tick();
  })();
  </script>
</body>
</html>
